

> 재귀 했던 것 손으로 짚으면서 마무리하기
```python
 def abc(level):
     # print('#'.end = '')
     if level == 2 :
         return

     for i in range(2):
         # print('#'.end='')
         abc(level+1)
         # print('#'.end='')
 abc(0) -->
```

___

> 재귀 누적합 구하기

* sum을 전역변수로
```python
arr=[1,2,3,4,5,6]
sum=3
def abc(level):
    global sum
    if level==5:
        print(sum)
        return

    print(sum)
    sum+=arr[level+1]
    abc(level+1)

abc(0)
```

* sum을 지역변수로
```python
def abc(level, sum):
    if level == 5:
        print(sum)
        return
    print(sum)
    abc(level + 1, sum + arr[level + 1])


abc(0, 3)  

```

___

> 누적합 거꾸로 출력하기

```python

def abc(level):
    global sum
    if level==5:
        print(sum)
        return
    sum+=arr[level+1]
    abc(level+1)
    sum-=arr[level+1]
    print(sum)

abc(0)

```

___

> 3개의 카드 묶음에서 1장씩 뽑을 때. 나올 수 있는 모든 합 출력

``` python
arr=[3,7,1,5]
# lv=3
# br=4
sum=0

def abc(level):
    global sum
    if level==3:
        print(sum, end=' ')
        return
    for i in range(4):
        sum+=arr[i]
        abc(level+1)
        sum-=arr[i]

abc(0) # level
```

___

```python
 def abc(level,sum):
     if level==3:
         print(sum,end=' ')
         return
     for i in range(4):
         abc(level+1,sum+arr[i])

 abc(0,0) # level sum
```

___

>최소동전사용개수
```python
changes=int(input())
coin=[100,70,10]
# br 3
# level ??
# return -> changes가 음수
Min=int(21e8)
def abc(level,chan):
    global Min
    if chan<0:
        return

    if chan==0:
        if level<Min:
            Min=level

    for i in range(3):
        abc(level+1,chan-coin[i])


abc(0,changes)
print(Min)


```

___

> 재귀 경로 출력하기
```python
arr=['a','b','c']
path=['']*5


def abc(level):
    if level==2:
        for i in range(level):
            print(path[i],end=' ')
        print()
        return

    for i in range(3):
        path[level]=arr[i]
        abc(level+1)
        path[level]=0

abc(0)

```


















