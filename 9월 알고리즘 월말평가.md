> 1번
- 배열 순회하며 특정 조건 찾기
- 현재 값보다 적은 것등등. 몇번 사이클 돌아야 하는가

---

> 2번
- 패턴 찾기
- 배열속 패턴찾기, 변화 가능
- 트리 순회(전위, 중위, 후위)


```
# 이진트리의 순회

> 전위순회(Preorder Traversal)
현재 노드n을 방문한다(출력한다).
현재 노드n의 왼쪽 서브트리로 이동한다(재귀).
현재 노드n의 오른쪽 서브트리로 이동한다(재귀).


> 중위순회(Inorder Traversal)
현재 노드n의 왼쪽 서브트리로 이동한다(재귀).
현재 노드n을 방문한다(출력).
현재 노드n의 오른쪽 서브트리로 이동한다(재귀).


> 후위순회(Postorder Traversal)
현재 노드n의 왼쪽 서브트리로 이동한다(재귀).
현재 노드n의 오른쪽 서브트리로 이동한다(재귀).
현재 노드n을 방문한다(출력).

```

> 3
- 컴퓨팅 사고력
- 빅오 개념 푸는 과정까지
- 이산수학 역 이 대우 개념

```
명제 와 증명

수학에서는 애매모호 한것을 싫어함. 딱떨어지고 분명해야함..
조건 식이나 정의가 있을때.. 수학적으로 증명을 항상 함
수학에서 어떠한 명제가 있으면.. 그 명제가 참인지 확인하는 과정을 증명
명제: 참 거짓을 판별할 수 있는 문장이나 식같은 것을 명제라 한다.
증명을 통해서 판단.

명제에 대한 
                       
명제: 6은 2의 배수 이고 3의 배수이다. (and)
부정: 6은 2의 배수가 아니거나 3의 배수가 아니다. (or)
                            

명제: 6의 배수라면 3의 배수이다.
역 (가정과 결과의 위치를 바꿈) : 3의 배수이면 6의 배수이다.
이 (가정과 결과를 부정) : 6의 배수가 아니면 3의배수도 아니다.
대우 (가정과 결과를 다 부정하고 그 위치를 바꿈)
       : 3의 배수가 아니면 6의 배수도 아니다.
명제에 대한 대우가 참이면 그 명제는 참

n제곱이 짝수면 n은 짝수다
역: n이 짝수면 n제곱은 짝수다.
이: n제곱이 홀수면 n은 홀수다
대우: n이 홀수면 n제곱은 홀수이다.
n이 홀수라면 n=2k+1 이라고 표현 가능
n제곱은 = (2k+1)^2 ->  4k^2+4k+1 -> 2(2k^2+2k)+1 (홀수)
즉 n이 홀수면 n제곱도 홀수다.


명제: n제곱이 3의 배수이면 n은 3의 배수다
3이 3의 배수가 아니면 n제곱은 3의 배수가 아니다.
3K+1  -> (3k+1)^2  -> 9k^2+9k+1 -> 3(3k^2+3k)+1 (3의 배수 아님)
3K+2 도 마찬가지...


시간복잡도
최선 표기법
최악 표기법 (ps에서는 최악의(큰) 변수값으로 알고리즘 성능평가 -> 빅오 표기)
평균 표기법

빅오- 최고차항만 고려한다.
      - 상수 무시한다.
      - 왜 무시하느냐? 최악의 경우
        무한대로 커지는 값에 비하면 
        상수는 지극히 작은 값이니까 무시해도
        결과에 큰 영향을 끼치지 않음

O(n-1)+1 명제가 있는데
이 명제의 시간 복잡도는 O(n)이라는 데 왜? 증명하라.
n이 무한으로 커진는 상수로 보고 -> n만 생각한다.
O(n)=O(n-2)+1
O(n)=O(n-k)+k
O(n)=O(0)+n , n=k
O(n)=1+n

O(2n^2+2n+1) -> O(n^2)
O(n^2)=O(2(n^2+n)+1)
         =O(k(n^2+n)+k)
         =O((n^2+n)), 
         =O(n(n+1))
         =O(n(n+k)
         =O(n(n))
         
```


