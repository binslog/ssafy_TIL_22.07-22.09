## 20220810 정리(알고리즘 -배열)
___


* 2차원 배열의 선언
    - 1차원 list를 묶어놓은 list
    - 2차원 이상의 다차원 List는 차원에 따라 Index를 선택
    - 2차원 List의 선언

Example) arr = [[0,1,2,3],[4,5,6,7]]


```python
3
1 2 3                   * N = int(input)
4 5 6                   * arr = [list(map(int,input().split()))]
7 8 9

3
123                 * N = int(input)
456                 * arr = [list(map(int,input())) for _ in range(N)]
789
```

> 배열 순회

= N * M 배열에 N * M 개의 모든 원소를 빠짐 없이 조사하는 방법


* 행 우선 순회
```python

for i in range(n):
    for j in range(m):
        array[j][i]
```

* 열 우선 순회

* 지그재그 순회



___

> 부분집합 합(subset sum)

* 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에
그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지 알아보자

* 예를 들어, [-7, -3, -2, 5, 8]이라는 집합이 있을 때, [-3, -2, 5]는 이 부분 집합이면서 (-3) + (-2) + 5 = 0 이므로 이 경우는 참이 된다.

> 부분집합 생성하기

```python
bit = [0,0,0,0]
for i in range(2):
    bit[0] = i # 0번째원소
    for j in range(2) :
        bit[1] = j # 1번째원소
        for k in range(2):
            bit[2] = k # 2번째원소
            for l in range(2) :
                bit[3] = 1 # 3번째원소
                print_subset(bit)
```

> 비트연산자
* & : 비트 단위로 AND 연산을 한다.
* | : 비트 단위로 OR 연산을 한다.
* << : 피연산자의 비트 열을 왼쪽으로 이동시킨다. 
* >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

* <<연산자
= 1<< n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

* & 연산자
= i&(1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.


> 보다 간결하게 부분집합을 생성해보자!

```python
arr = [3,6,7,1,5,4]
n = len(arr)       # n : 원소의 개수

for i in range(1<<n) :   # 1<<n : 부분 집합의 개수
    for j in range(n) :  # 원소의 수만큼 비트를 비교한다.
        if i & (1<<j) :  # i의 j번 비트가 1인 경우
            print(arr[j], end="") # j번 원소
    print()
print()


```

___
> 검색(Search)

: 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

* 목적하는 탐색 키를 가진 항목을 찾는 것
= Search key : 자료를 구별하여 인식할 수 있는 키

* 검색의 종류 : 순차 검색, 이진검색 , 해쉬

> 순차 검색(Sequential Search)
* 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 가장 간단하고 직관적인 검색 방법
- 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 유용
- 단순하지만 시간이 많이 걸린다.

> 정렬되어 있지 않은 경우
* 검색 과정
    - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교
    - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
    - 자료구조의 마지막에 이를때까지 검색 대상을 찾지 못하면 실패.

* 찾고자 하는 원소의 순서에 따라 비교회수가 결정된다
    - 첫 번째 원소를 찾을 때는 1번 비교, 2번 비교
    - (1/n) * (1+2+...+n)


___

> 이진 검색(Binary Search)
* 자료 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    - 목적 키를 찾을 때 까지 이전 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 수행한다.
    - 반드시 정렬이 되어 있어야한다.

* 중앙에 있는 원소를 고르고 목표값을 비교한 다음에 목표값이 중앙 원소보다 작으면 왼쪽 비교, 그 다음 오른쪽 비교

* 구현
- 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다.
- 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요하다.


> 이진 검색 알고리즘

```python
def binarySearch(a,N,key)
    start = 0
    end = N-1
    while start <= end :
        middle = (start + end) // 2
        if a[middle] == key : # 검색 성공
            return true
        elif a[middle] > key :
            end = middle - 1
        else:
            start = middle + 1

    return false

```

___ 
## 오후수업
___

### 인덱스

* 원본 데이터 배열과 별개로, 배열 인덱스를 추가한 예

> 선택정렬(Selection Sort)

* 주어진 자료들 중에서 가장 작은 값의 원소부터 차례대로 선택한다
* 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것

* 정렬 과정
    - 주어진 리스트 중에서 최소값을 찾고
    - 그 값을 리스트의 맨 앞에 위치한 값과 교환
    - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 

___

> 셀렉션 알고리즘(Selection Algorithm)

* 저장되어 있는 자료로부터, k번째로 큰 혹은 작은 원소를

___

N = 3
M = 4
* N개의 원소를 갖는 0으로 초기화된 1차원 배열
arr1 = [0]*N


* 크기가 NxM이고 0으로 초기화된 2차원 배열
arr2 = [[0]*M for _ in range(N)]




