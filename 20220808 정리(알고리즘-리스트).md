## 20220808 알고리즘 리스트 정리
___
#### 알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 절차이다.
___

=> 간단하게 말하면 어떠한 문제를 해결하기 위한 절차.

* 컴퓨터 분야에서 알고리즘을 표현하는 방법은 크게 두 가지
* 의사코드(슈도코드, Pseudocode)와 순서도
* APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.
* 정확성, 작업량, 메모리 사용량, 단순성, 최적성


* 알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다.
* 시간 복잡도(Time Complexity)
    - 실제 걸리는 시간을 측정
    - 실행되는 명령문의 개수를 계산


* 문법-> 자료구조-> 알고리즘 
( + 컴퓨터 구조를 알면 좋다.)


> 시간 복잡도 : 빅-오(O) 표기법

* 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 N에 대한 항만을 표시한다.
* 계수(Coefficent는 생략하여 표시)
___

>배열
* 일정한 자료형을 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
* 아래의 예는 6개의 변수를 사용해야 하는 경우, 이를 배열로 바꾸어 사용한다.
* Num=[1,2,3,4,5]

```python
# <최대값 찾기>
N=int(input())
arr = list(map(int,input().split()))
print(arr)
maxV=arr[0]
for i in range(1,N):
    if arr[i]>maxV :
     maxV=arr[i]

print(maxV)

# <최대값의 위치>
N-int(input())
arr = list(map(input().split()))
maxIdx = 0 # 가정
for i in range(1,N):
    if aff[maxIdx] < arr[i] : #이런 연습을 계속 해야한다.
        maxIdx = i 

```
___

> 정렬


: 2개 이상의 자료를 기준에 의해 작은값부터 큰 값(오름차순: ascending),
혹은 그 반대의 순서대로(내림차순: descending) 재배열하는 것

* 종류 : 버블, 카운팅, 선택, 퀵, 삽입, 병합
* APS 과정을 통해 자료구조와 알고리즘을 학습하면서 다양한 형태의 정렬을 학습한다.

___

> 버블 정렬(Bubble Sort)

: 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

<정렬 과정>
* 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
* 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
* 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

___


> 카운팅 정렬(Counting Sort)

= 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

* 정수나 정수로 표현할 수 있는 자료에 대해서만 적용이 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문
* 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.


* 버블 정렬은 코딩이 가장 손쉽고, 카운팅 정렬은 n이 비교적 작을 때만 가능하다는 특징.

```python
tmp= [0] * N
c = [0] * 101 # [0]의 역할은 값이 들어가있지 않다는 의미이다.

for i in range(N):
    c[arr[i]] += 1

for j in range(1,101):
    c[j] += c[j-1]

for i in range(N-1, -1, -1):
    c[arr[i]] -= 1
    tmp[c[arr[i]]] = arr[i]

```

___

> Baby-gin Game

* 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
* 그리고, 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.
* 5자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

___

> 완전 검색(Exaustive Search)
* 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
* Brute-force 혹은 generate-and-test 기법으로 불린다.
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
* 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.

* 모든 경우의 수를 생성하고 테스트 하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률은 낮다.
* 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

> 완전 검색을 활용한 baby-gin 접근
* 모든 경우의 수인 6글자를 모두 나열하고, 앞의 3자리와 뒤의 3자리를 자른다.

___

> 순열(Permutation)
* 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
* 사로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.(nPr)
* npr = n*n-1*n-r+1 , n!=n*(n-1)*...*1

> 예시) {1,2,3}을 토함하는 모든 순열을 생성하는 함수
* 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 통해 아래와 같이 구현

```python
for i1 in range(1,4):
    for i2 in range(1,4):
        if i2 != i1 :
            for i3 in range(1,4):
                if i3 != i1 and i3 != i2:
                    print(i1,i2,i3)

```

___

> 탐욕(Greedy) 알고리즘
* 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
* 여러 경우 중 하나를 결정해야 할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 최적이라는 보장은 없다.
* 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근.


> 동작과정
1) 해 선택 : 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인한다.
아직 전체 문제의 해가 완성되지 않았다면, 1)의 해 선택부터 다시 시작한다.


> 예시
* 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 할까?

1) 해 선택 : 여기에서는 멀리 내다볼 것 없이 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들므로 현재 고를 수 있는 가장 단위가 큰 동전 하나를 골라 거스름돈 추가

2) 실행 가능성 검사: 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인한다.
초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 1)로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다.

3) 해 검사: 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드려야하는 액수와 일치하는 셈이다. 액수가 보자라면 다시 1)로 돌아간다.


> Baby-gin을 완전검색이 아닌 방법으로 풀어보자
* 6개의 숫자는 6자리의 정수 값으로 입력된다.
* counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다.

* arr = list(map(int,input()))은 알아두자!

```python

num = 456789 # Baby Gin 확인할 6자리 수
c = [0] # 6 자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6) :
    c[num % 10] += 1
    num //= 10

i=0
tri=num=0
while i < 10 :
    if c[i] >= 3 : #triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri +=1
        continue;

    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >=1 : #run 조사 후 데이터 삭제
        c[i] -=1 
        c[i+1] -=1
        c[i+2] -=1
        run += 1
        continue
    i +=1

if run + tri == 2 : print("Baby Gin")    
else: print("Lose")

```

